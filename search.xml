<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CentOS安装python3]]></title>
    <url>%2F2018%2F12%2F13%2Fcentos%E5%AE%89%E8%A3%85python3%2F</url>
    <content type="text"><![CDATA[需要运行基于 Python3 的 Django 项目，服务器默认安装的为 python2 ,需要安装Python3 以下命令均为在 root 身份下执行，如果权限不够，请切换管理眼身份，或在每条命令前添加 sudo 。 安装Python3创建目录创建 python3 的下载安装目录1$ mk /usr/local/python3 下载解压可以在 python 的 官网 找到最新的 python3 安装包，然后使用 wget 命令下载下来。这是 Python 3.7.1 的页面，最下面找到下载地址，其中第一个为 tgz 格式的压缩包 下载完成后进行解压12$ wget https://www.python.org/ftp/python/3.7.1/Python-3.7.1.tgz$ tar -xzvf Python-3.7.1.tgz 安装依赖在 python3 进行编译安装时，需要用到其它的依赖包，要先进行安装 1234$ yum install gcc-c++$ yum install pcre pcre-devel$ yum install zlib zlib-devel$ yum install openssl openssl--devel 编译安装1234$ cd Python-3.7.1$ ./configure --prefix=/usr/local/python3 # 生成makefile --prefix 设置安装路径$ make # 编译$ make install # 安装 配置链接可以使用 which python 来查看原来python的位置12$ which python/usr/bin/python ls -l 查看软链接设置 123lrwxrwxrwx 1 root root 7 Nov 15 00:19 python -&gt; python2lrwxrwxrwx 1 root root 9 Nov 15 00:19 python2 -&gt; python2.7-rwxr-xr-x 1 root root 7216 Jul 13 21:07 python2.7 创建 python3 的软链接1$ ln -s /usr/local/python3/bin/python3 /usr/bin/python3 当前链接情况, python 和 python2 指向 python 2.7.5 ，python3 指向 python 3.7.11234lrwxrwxrwx 1 root root 7 Nov 15 00:19 python -&gt; python2lrwxrwxrwx 1 root root 9 Nov 15 00:19 python2 -&gt; python2.7-rwxr-xr-x 1 root root 7216 Jul 13 21:07 python2.7lrwxrwxrwx 1 root root 30 Dec 13 01:46 python3 -&gt; /usr/local/python3/bin/python3 安装pip3python3.7 已经附带了pip3 ，在 /usr/local/python3/bin 中可以看到 pip3 创建pip3软链接1$ ln -s /usr/local/python3/bin/pip3 /usr/bin/pip3 此时就可以正常使用 python3 ，pip3 来使用 python3.7.1 了。]]></content>
      <categories>
        <category>linux - centos</category>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python sqlite3 数据库操作的自动提交]]></title>
    <url>%2F2018%2F12%2F11%2Fpython-sqlite3-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%E7%9A%84%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4%2F</url>
    <content type="text"><![CDATA[在一个爬虫中使用了Sqlite3数据库，在将内容写入数据库时，可以正常执行，并且使用同一个游标可以正常读出数据，但是数据库中并没有内容。 在网上搜索时发现，是因为sqlite的事务控制导致，其中在执行数据库操作时，会有两种commit状态。 123456789101112131415智能commit状态: 生成方式: 在connect()中不传入 isolation_level, 此时isolation_level==&apos;&apos; 在进行 执行Data Modification Language (DML) 操作(INSERT/UPDATE/DELETE/REPLACE)时, 会自动打开一个事务, 在执行 非DML, 非query (非 SELECT 和上面提到的)语句时, 会隐式执行commit 可以使用 connection.commit()方法来进行提交 注意: 不能和cur.execute(&quot;COMMIT&quot;)共用 自动commit状态: 生成方式: 在connect()中传入 isolation_level=None 这样,在任何DML操作时,都会自动提交 事务处理 connection.execute(&quot;BEGIN TRANSACTION&quot;) connection.execute(&quot;COMMIT&quot;) 如果不使用事务, 批量添加数据非常缓慢 智能commit状态即在下面这种非数据修改操作时，会自动执行commit操作。1result = c.execute("select * from bing_images") 当进行数据库写入时，这种数据修改操作并不会自动提交,需要在执行完成后进行手动提交(需要connection.commit()进行提交)。12c.execute(insert_sql)conn.commit() # connection 自动commit状态在这种情况下，无论是数据修改操作还是非数据修改操作都会自动提交。]]></content>
      <categories>
        <category>数据库</category>
        <category>sqlite3</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[django models中设置字段允许为空]]></title>
    <url>%2F2018%2F12%2F11%2Fdjango-models%E4%B8%AD%E8%AE%BE%E7%BD%AE%E5%AD%97%E6%AE%B5%E5%85%81%E8%AE%B8%E4%B8%BA%E7%A9%BA%2F</url>
    <content type="text"><![CDATA[在Django-models中定义数据库字段时，其字段默认是不允许为空的，在直接向数据库中插入非全部字段时，会直接发生下面错误： sqlite3.IntegrityError: NOT NULL constraint failed: bing images.drk 即 sqlite3 完整性错误，其中NOT NULL 约束失败，默认字段不允许为空。 可以通过在models的字段定义上设置 null = True 来解决 1url = models.CharField(max_length=200, null=True) Django中源代码如下：12345678910def formfield(self, **kwargs): # Passing max_length to forms.CharField means that the value's length # will be validated twice. This is considered acceptable since we want # the value in the form field (to pass into widget for example). defaults = &#123;'max_length': self.max_length&#125; # TODO: Handle multiple backends with different feature flags. if self.null and not connection.features.interprets_empty_strings_as_nulls: defaults['empty_value'] = None defaults.update(kwargs) return super().formfield(**defaults)]]></content>
      <categories>
        <category>Python</category>
        <category>Django</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HEXO]]></title>
    <url>%2F2018%2F11%2F22%2FHEXO%2F</url>
    <content type="text"><![CDATA[hexo 中的 public 目录每次生成静态文件(hexo g)都会重新生成 修改about页面信息需要在 soure-about-index.md 中修改]]></content>
  </entry>
  <entry>
    <title><![CDATA[修改wordpress的翻译文件]]></title>
    <url>%2F2018%2F11%2F20%2F%E4%BF%AE%E6%94%B9wordpress%E7%9A%84%E7%BF%BB%E8%AF%91%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[之前WordPress博客的首页部分内容翻译错误，就想手动修改一下。 使用 Xftp 登录服务器1、找到wordpress的安装目录 2、在 /wordpress/wp-content/languages/themes 目录下，找到你主题的对应翻译文件。 每个主题都有两个 .mo .po 类型的文件 其中po文件,即Portable Object(可移植对象) 是翻译人员进行编写的翻译文件1234567891011#: inc/main-funtions.php:469msgid &quot;Github&quot;msgstr &quot;Github&quot;#: inc/main-funtions.php:461msgid &quot;LinkedIn&quot;msgstr &quot;领英&quot;#: inc/main-funtions.php:449msgid &quot;Facebook&quot;msgstr &quot;脸书&quot; mo 文件 Machine Object(机器对象) 是由 po 文件编译成的二进制文件,应用程序可以通过读取 .mo 文件进行对应语言的翻译显示。 我们将要修改主题翻译的 .po 文件下载下来。 修改翻译我们只能修改 .po 文件后再将其编译为 .mo 文件，其中编译软件可以使用 Poedit 。使用 Poedit 打开下载的 .po 文件，修改想要修改的翻译内容，修改完成后点击左上角 文件 - 编译为mo - 保存文件。 上传覆盖编译完成后将编译完成的 .mo 文件上传到服务器，将原来的mo文件覆盖。此时重新打开 wordpress 博客首页，翻译就已经生效了。]]></content>
      <categories>
        <category>Blog</category>
        <category>WordPress</category>
      </categories>
      <tags>
        <tag>WordPress</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 更换主题]]></title>
    <url>%2F2018%2F11%2F16%2Fhexo-%E6%9B%B4%E6%8D%A2%E4%B8%BB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[选择主题可以在 有哪些好看的 Hexo 主题? 找个自己喜欢的主题，我选择的是 hexo-theme-next 主题 下载主题打开在 Hexo 根目录 打开 CMD12mkdir theme/nextgit clone https://github.com/theme-next/hexo-theme-next themes/next 安装主题打开 _config.yml 配置文件,修改主题为 next123$ hexo g # 重新生成静态文件$ hexo s # 本地预览效果$ hexo d # 部署到Github]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F11%2F16%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
